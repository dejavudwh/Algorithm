| Number | Title                                                | Difficulty | Tags                           |
| ------ | ---------------------------------------------------- | ---------- | ------------------------------ |
| 274    | [H-Index](https://leetcode-cn.com/problems/h-index/) | Medium     | 约束区间；累加判断边界；排序； |



### 解题思路

> 数组遍历 排序 约束区间 累加判断边界

分析题目的h指数：**总共**有 h 篇论文分别被引用了**至少** h 次。且其余的 *N - h* 篇论文每篇被引用次数 **不超过** *h* 次。

想一下这个问题的模型，很明显是在求一个最大区间[0, h]，这个区间上所有的值都大于等于h。这就可以很自然的想到需要先排序。

<img src="E:\IDEASpace\Algorithm\leetcode-doc\array\image-20210114003406636.png" alt="image-20210114003406636" style="zoom:50%;" />

- 排序
- 这里有个具体细节：怎么从排完序后的数组找到这个区间。（可以一般化：累加判断边界，需要注意因为数值不是±1递增递减发生跳跃而忽略某个结果，但是这题不会出现这样的问题，因为结果必是两者小的那个。
  - 从数组的末尾开始遍历（因为之前是升序排序
  - 累计论文数（可以选择论文数或者引用数做基准，但是判断条件要变
  - 查看当前引用数是不是仍然大于论文数
    - 如果是继续遍历，累计论文数
    - 返回当前值

现在思考时间复杂度的问题，也就是选择排序的方法，如果选择基于比较的排序，那么最低的时间复杂度都需要O(nlogn)，所以如果想压缩时间，只有选择其它的排序方法：计数排序。但是计数排序的适用范围是有限的，因为它需要很大的空间。

但是这题是适用的，因为可以通过一些推导来优化数组的长度：h指数必定<=n论文数，所以将大于n的引用数当作n来计算并不会影响计算结果。这就优化了计数排序需要的空间。

### 代码

```java
class Solution {
    public int hIndex(int[] citations) {
        int n = citations.length;
        int[] papers = new int[n + 1];

        // 计数排序
        for (int i = 0; i < n; i++) {
            int c = citations[i];
            // 如果引用数超过论文数
            // 因为h指数不会大于n 所以可以直接计入n的
            if (c > n) {
                papers[n]++;
            } else {
                papers[c]++;
            }
        }

        // 查找h
        int h = n;
        for (int s = papers[n]; h > s; s += papers[h]){
            h--;
        }

        return h;
    }
}
```

